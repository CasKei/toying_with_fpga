module game_CU (
    input clk,  // clock
    input rst,  // reset
    
    // button inputs
    input p1rollbtn,
    input p1holdbtn,
    input p2rollbtn,
    input p2holdbtn,    
    input rstgamebtn,
    
    // outputs
    output playerturn[1],
    output p1curr[8],
    output p1acc[8],
    output p2curr[8],
    output p2acc[8],  
    output currdice[3]
  ) {

  // edge detectors for all buttons
  edge_detector det_p1roll(#RISE(1), #FALL(0), .clk(clk));
  edge_detector det_p1hold(#RISE(1), #FALL(0), .clk(clk));
  edge_detector det_p2roll(#RISE(1), #FALL(0), .clk(clk));
  edge_detector det_p2hold(#RISE(1), #FALL(0), .clk(clk));
  //edge_detector det_rst(#RISE(1), #FALL(0), .clk(clk));

  // button conditiners for all buttons
  button_conditioner p1roll (.clk(clk), .in(p1rollbtn));
  button_conditioner p1hold (.clk(clk), .in(p1holdbtn));
  button_conditioner p2roll (.clk(clk), .in(p2rollbtn));
  button_conditioner p2hold (.clk(clk), .in(p2holdbtn));
  //button_conditioner reset (.clk(clk), .in(rstgamebtn));
  
  // registers (dffs) to store data
  dff st_p1curr[8] (#INIT(0), .clk(clk), .rst(rst));
  dff st_p1acc[8] (#INIT(0), .clk(clk), .rst(rst));
  dff st_p2curr[8] (#INIT(0), .clk(clk), .rst(rst));
  dff st_p2acc[8] (#INIT(0), .clk(clk), .rst(rst));
  dff st_currdice[3] (#INIT(0), .clk(clk), .rst(rst));
  dff st_turn[1] (#INIT(0), .clk(clk), .rst(rst));
  dff st_temp[8] (#INIT(0), .clk(clk), .rst(rst));
  
  // instantiate modules
  alu_16 alu;
  dice diceroll(.clk(clk), .rst(rst));
  
  // instantiate fsm
  fsm game (.clk(clk), .rst(rst)) = {
    IDLE,
    P1_TURN,
    P1_CHANGE_DICE_SCORE,
    P1_BRANCH_DICEROLL,
    //CHECK_P1BUTTONCOUNT,
    BRANCH_P1BUTTON,
    INCREASE_P1ACCSCORE,
    RESET_CURRENT_P1SCORE,
    INCREASE_P1_CURRENTSCORE,
    SUM_P1POSSIBLESCORE,
    CHECKP150,
    BRANCH_P1CONDITION,
    //P2 states
    P2_TURN,
    P2_CHANGE_DICE_SCORE,
    P2_BRANCH_DICEROLL,
    BRANCH_P2BUTTON,
    INCREASE_P2ACCSCORE,
    RESET_CURRENT_P2SCORE,
    INCREASE_P2_CURRENTSCORE,
    SUM_P2POSSIBLESCORE,
    CHECKP250,
    BRANCH_P2CONDITION,
    RESET_COUNTER,
    CHECK_WINNER,
    BRANCH_WINNER,
    P1WINS,
    P2LOSE,
    P2WINS,
    P1LOSE,
    GAMEOVER
  };
  
  always {
    // assignments if needed
    alu.a = 0;
    alu.b = 0;
    alu.alufn = b111111; // no operation
    st_temp.d = alu.out;
    
    // detect buttons
    det_p1roll.in = p1roll.out;
    det_p1hold.in = p1hold.out;
    det_p2roll.in = p2roll.out;
    det_p2hold.in = p2hold.out;
    diceroll.rollbtn = 0;
    
    
// fsm
    case(game.q) {
    
// IDLE
      game.IDLE:
        // fixed outputs: playerturn 0, p1curr, p1acc, p2curr, p2acc
        // all init values are 0, so outputs here shld be all 0
        playerturn = st_turn.q; // 0 is player 1 turn
        p1curr     = st_p1curr.q;
        p1acc      = st_p1acc.q;       
        p2curr     = st_p2curr.q;
        p2acc      = st_p2acc.q;
        currdice = st_currdice.q;
        
        if (det_p1roll.out || det_p1hold.out || det_p2roll.out || det_p2hold.out) {
          // use this to start game to P1_TURN
          // basically press any button to initiate game
          game.d = game.P1_TURN;
        } else {
          game.d = game.IDLE;
        }
        
        
// P1_TURN (P1 can choose roll or hold, else stay in state)
      game.P1_TURN:
        // show all currently stored outputs
        playerturn = st_turn.q; // 0 is player 1 turn
        p1curr     = st_p1curr.q;
        p1acc      = st_p1acc.q;       
        p2curr     = st_p2curr.q;
        p2acc      = st_p2acc.q;
        currdice   = st_currdice.q;
        
        if (det_p1roll.out) {
          diceroll.rollbtn = det_p1roll.out;
          st_currdice.d = diceroll.out;
          currdice = st_currdice.q;
          game.d = game.P1_CHANGE_DICE_SCORE;
        } else if (det_p1hold.out) {
          game.d = game.INCREASE_P1ACCSCORE;
        } else {
          game.d = game.P1_TURN;
        }

        
// P1_CHANGE_DICE_SCORE (P1 has rolled and currdice is stored and displayed)
      game.P1_CHANGE_DICE_SCORE:
        // show all currently stored outputs
        playerturn = st_turn.q; // 0 is player 1 turn
        p1curr     = st_p1curr.q;
        p1acc      = st_p1acc.q;       
        p2curr     = st_p2curr.q;
        p2acc      = st_p2acc.q;
        currdice   = st_currdice.q;
        
        // if currdice is 1: RESET_CURRENT_P1SCORE,
        //else : P1_BRANCH_DICEROLL
        if (st_currdice.q == 1) {
          game.d = game.RESET_CURRENT_P1SCORE;
        } else if (st_currdice.q == 0){
          // this is an error, but catch and restart game
          game.d = game.IDLE;
        } else if (st_currdice.q == 2||st_currdice.q == 3||st_currdice.q == 4||st_currdice.q == 5||st_currdice.q == 6){
          // rolled 2 to 6
          game.d = game.P1_BRANCH_DICEROLL;
        } else {
          // final catch
          game.d = game.P1_CHANGE_DICE_SCORE;
        }
        
        
// P1_BRANCH_DICEROLL (P1 has rolled and currdice is 2 to 6)
      game.P1_BRANCH_DICEROLL:
        // show all currently stored outputs
        playerturn = st_turn.q; // 0 is player 1 turn
        p1curr     = st_p1curr.q;
        p1acc      = st_p1acc.q;       
        p2curr     = st_p2curr.q;
        p2acc      = st_p2acc.q;
        currdice   = st_currdice.q;
        
        // p1curr = old p1curr + currdice
        alu.a = st_p1curr.q;
        alu.b = st_currdice.q;
        alu.alufn = b000000; // add
        st_p1curr.d = alu.out; // curr + thisroll
        
        // sum possible score for check(curr + acc)
        game.d = game.SUM_P1POSSIBLESCORE;
        
        
// SUM_P1POSSIBLESCORE (use temp to store curr + acc, dont update until hold)
      game.SUM_P1POSSIBLESCORE:
        // show all currently stored outputs
        playerturn = st_turn.q; // 0 is player 1 turn
        p1curr     = st_p1curr.q;
        p1acc      = st_p1acc.q;       
        p2curr     = st_p2curr.q;
        p2acc      = st_p2acc.q;
        currdice   = st_currdice.q;
        
        // temp = p1curr + p1acc
        alu.a = st_p1curr.q;
        alu.b = st_p1acc.q;
        alu.alufn = b000000;
        st_temp.d = alu.out;
        
        game.d = game.CHECKP150;
        
        
// CHECKP150
      game.CHECKP150:
        // show all currently stored outputs
        playerturn = st_turn.q; // 0 is player 1 turn
        p1curr     = st_p1curr.q;
        p1acc      = st_p1acc.q;       
        p2curr     = st_p2curr.q;
        p2acc      = st_p2acc.q;
        currdice   = st_currdice.q;
        
        // 
        
        
        
        
        
        
        
        
        

        
        
        
        
        
        
        
        
        
        
        
        
    }
    
    
    
    
  }
}
